import {Callout, Tab, Tabs} from 'nextra/components'
import {LatestReadings} from "../../../components/ui/sections/latest-readings";

# DRD Architecture

*QUAK developed DRD architecture (DTO's Repository Domain) for SPA frontend.*

## What is DRD?

Example of DRD Architecture for `users` feature:

### Graph

```mermaid
flowchart TD
    D(DTO)
    E(Repository)
    F(Domain)
    G(Use Case)

    D --> E
    F -->|Factories creates Models from DTOs| D
    F -->|use Repo Interfaces| E

    G -->|use Models, Services, Stores, Politics| F
    G -->|use Repo Interfaces| E
```

### Description

<Callout emoji="ðŸ‘¾" type="info">
  **DRD Architecture** is made as an elevation of **DDD** (Domain Driven Design) to frontend. It is based on **Reactivity** and **DDD** vision.
</Callout>

DRD split business logic from presentation layer/use case. DRD is framework agnostic architecture that can be used in any programming language.

DRD focus on models that have business bahavior and proper abstraction for managing data from `BACKEND` &rarr; `FRONTEND`.

DRD makes views creation simple, secure and fast.

## Why?

- **Easy to maintain** - you can easily change field names in translations layer (DTO) and it will be automatically changed in all other layers, etc.
- **Easy to test** - you can easily test each layer because it is regulary single responsibility cases
- **Easy to understand** - you can easily understand what is going on in each layer
- **Easy to scale** - you can easily add any new views once you created proper foundation
- **Beautiful models** - finally you can have beautiful models with methods and not only data
- **Reactivity** - you can easily react to any change in store, your views are always up to date and way simpler

## When?

- **When you have frontend client** - DRD Architecture makes sense only if you have separate frontend client, like SPA or mobile app
- **Complexity** - DRD Architecture makes sense for small and enterprise projects, but not for simple projects (let HTML and JS/TS be the king in simple apps)

## Example

*Example common feature: `users`*

<Tabs selectedIndex={5} items={['DTO /types', 'DTO fetch-user', 'DTO create-user', 'Repository user', 'Domain user', 'Domain user-creation']}>
  <Tab>
  ```typescript
    type UserID = string;
    type Role = "admin" | "user" | "moderator";
  ```
  </Tab>
  <Tab>
  ```typescript
  import {UserID, Role} from './types';

  type FetchUserResponse = {
    id: UserID;
    user_name: string;
    roles: Role[];
  };

  class FetchedUserDto {
    id: UserID;
    username: string;
    roles: Role[];

    constructor(dto: FetchUserResponse) {
      this.id = dto.id;
      this.username = dto.user_name;
      this.roles = dto.roles;
    }
  };
  ```
  </Tab>
  <Tab>
  ```typescript
  import {UserID, Role} from './types';

  type CreateUserResponse = {
    id: UserID;
    user_name: string;
    roles?: Role[];
  };

  class CreateUserDto {
    user_name: string;
    roles: Role[];

    constructor(username: string, roles: Role[]) {
      this.user_name = username;
      this.roles = roles;
    }
  };

  class CreatedUserDto {
    id: UserID;
    username: string;
    roles: Role[];

    constructor(dto: CreateUserResponse) {
      this.id = dto.id;
      this.username = dto.user_name;
      this.roles = dto.roles;
    }
  };
  ```
  </Tab>
  <Tab>
  ```typescript
  class UserRepository {
    async fetchOne(id: UserID): Promise<FetchedUserDto> {
      return await fetch(`/api/users/${id}`)
        .then((response) => response.json())
        .then((response) => new FetchedUserDto(response));
    }

    async create(dto: CreateUserDto): Promise<CreatedUserDto> {
      return await fetch(`/api/users`, {
          method: 'POST',
          body: JSON.stringify(dto),
      })
        .then((response) => response.json())
        .then((response) => new CreatedUserDto(response));
    }
  }
  ```
  </Tab>
  <Tab>
  ```typescript
  import {UserID, Role} from './types';

  class User {
    id: UserID;
    username: string;
    roles: Role[];

    constructor(user: User) {
      Object.assign(this, user);
    }

    hasRole(role: Role): boolean {
      return this.roles.includes(role);
    }
  }

  const UserFactory = {
    fromFetchedUser(dto: FetchedUserDto): User {
      return new User({
        id: dto.id,
        username: dto.username,
        roles: dto.roles,
      });
    },
    fromCreatedUser(dto: CreatedUserDto): User {
      return new User({
        id: dto.id,
        username: dto.username,
        roles: dto.roles,
      });
    }
  };
  ```
  </Tab>
  <Tab>
  ```typescript
  import {UserFactory} from './user.model';

  class UserCreationService {
    constructor(
        private settings: Settings,
        private userRepo: UserRepository,
    ) {}

    async createUser(username: string, roles: Role): Promise<User> {
      if (username.length < this.settings.minUsernameLength) {
        throw new Error('Username is too short');
      }
      const response = await this.userRepo.create(new CreateUserDto(username, roles));
      return UserFactory.fromCreatedUser(response);
    }
  }
  ```
  </Tab>
</Tabs>

<p>This is it! Now you can use your models in views and use cases.</p>

<section className="rounded-2xl bg-lines flex mt-10 mb-20 h-20 w-full"></section>

<LatestReadings />
